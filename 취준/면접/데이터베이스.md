### 특징
1. **실시간 접근성** : 조회에 대해 실시간 처리에 의한 응답이 가능해야 한다.
2. **지속적인 변화** : 삽입, 삭제, 업데이트에 의해 데이터베이스는 동적인 상태이다.
3. **동시 공용** : 다수의 사용자가 동시에 같은 내용의 데이터를 조회할 수 있어야 한다.
4. **내용에 의한 참조** : 찾고자 하는 내용을 통해 조회한다.

### DDL, DML, DCL
* **DDL** : 데이터베이스 구조를 정의, 수정, 삭제하는 언어 (alter, create, drop)
* **DML** : 데이터베이스 내 자료를 조회, 삽입, 수정, 삭제하는 언어 (select, Insert, update, delete)
* **DCL** : 데이터에 대해 병행 수행 제어, 권한 관리를 위한 언어 (commit, rollback, grant, revoke)
	* **revoke** : 권한 철회

### TCL
* START TRANSACTION
* COMMIT
* ROLLBACK
* SAVEPOINT (SAVEPOINT까지만 롤백이 가능하다.) 
```MYSQL
SAVEPOINT S1;
ROLLBACK TO S1;
```

### SELECT 쿼리 수행 순서
	FROM, ON, JOIN > WHERE, GROUP BY, HAVING > SELECT > DISTINCT > ORDER BY > LIMIT

### 트리거
특정 테이블에 작용하는 삽입, 업데이트, 삭제 이벤트에 반응해 데이터베이스에서 자동으로 동작하도록 하는 기능
* 데이터베이스가 자동적으로 호출
* OLD, NEW 가상 줄 변수를 사용 가능

```MYSQL
DELIMITER $$

CREATE TRIGGER UPDATE_ITEM
AFTER UPDATE ON SALE_TABLE
FOR EACH ROW --모든 행에 적용

BEGIN 
	IF NEW.discount_rate != OLD.discount_rate
	THEN UPDATE item_table SET discount_rate = NEW.discount_rate 
	WHERE discount_tate = OLD.discount_rate;
	END IF;
END $$
 ```

### 인덱스
: 데이터베이스의 검색 속도를 향상시키는 방법으로, FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법 (책의 인덱스와 비슷함)

- B+Tree 인덱스 자료구조
    - 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이며,
    - BTree 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 합니다. 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조입니다.
- 해시 테이블
    - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현합니다.
    - 시간복잡도가 O(1)이라 검색이 매우 빠릅니다.
    - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않습니다.

```MYSQL
CREATE INDEX 인덱스이름 ON 테이블이름(필드이름1)
ALTER TABLE 테이블이름 DROP INDEX 인덱스이름;
ALTER TABLE 테이블이름 ADD (UNIQUE)INDEX 인덱스이름(컬럼명1, 컬럼명2...);
```


### 정규화
: **이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 과정**

* 이상현상 : 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류 
	1. 삽입 이상: 자료 삽입 시, 필요하지 않는 컬럼 값까지 삽입해야 하는 현상
	2. 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 생기는 현상
	3. 삭제 이상: 어떤 정보를 삭제 시, 의도치 않는 정보까지 삭제되는 현상

* 제 1 정규화 
: 테이블의 컬럼이 원자값(하나의 값)을 갖도록 분해

* 제 2 정규화
: 기본키가 아닌 속성이 기본키에 완전 함수 종속
	* 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것
* 제 3 정규화 : 이행적 함수 종속을 없애도록 분해
* BCNF 정규화 : 함수 종속성 X->Y가 성립할 때, 모든 결정자 X가 후보키가 되도록 분해

### 키 

- **유일성** : **하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.  
- **최소성** : 꼭 필요한 **최소한의 속성**들로만 키를 구성하는 성질  

1. 후보키 : 유일성( 각 행을 유일하게 식별할 수 있는 속성들의 집합이다.), 최소성
2. 기본키 : NULL값 X, 중복 X
3. 대체키
4. 슈퍼키 : 유일성
5. 외래키

? 기본키와 유일키의 차
null 값 허용의 차이

유일키는 기본키를 포'

### SQL

- 데이터는 **정해진 데이터 스키마에 따라 테이블에 저장**된다.
- 데이터는 **관계를 통해 여러 테이블에 분산**된다.

SQL 장점
- 명확하게 정의된 스키마, 데이터 무결성 보장
- 관계는 각 데이터를 중복없이 한번만 저장

SQL 단점
- 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
- 대체로 수직적 확장만 가능함

### NOSQL

  **스키마도 없고, 관계도 없다!**
NoSQL에서는 레코드를 문서(documents)라고 부른다.

NoSQL 장점
- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
- 수직 및 수평 확장이 가능하다.

NoSQL 단점
- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함, 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함
### 트랜젝션
: 작업의 완전성을 보장해주는 기능으로, 트랜젝션 설정 시, 일렬의 작업 중 하나만 작업이 처리되지 못하면 설정 이전의 상태로 복구해준다.

1. 원자성(Atomicity) 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
2. 일관성(Consistency) 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
3. 독립성(Isolation) 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
4. 영속성(Durability) 완료된 결과는 영구적으로 반영되어야 한다.

### DB 락
* 공유락 (Read Lock) : 데이터 읽기 시, 사용하는 락 (같은 공유락끼리 동시 접근 가능, 읽기만 가능)
* 베타락 (Write Lock) : 데이터 변경 시, 사용하는 락 (트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다, 읽기, 수정, 삭제 가능)

### Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.

- RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
- 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인(키워드를 PK로 맵핑하는 인덱스 테이블 생성) 지원으로 매우 빠른 검색이 가능합니다.


### 리플리케이션
 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식, 비동기 방식으로 노드들 간의 데이터를 동기화
![](https://blog.kakaocdn.net/dn/bHW2YF/btqKRO16Oln/UrvZZeMCO20q9xY0XKuKSK/img.png)

위의 그림은 MySQL의 Replication 방식에 대한 그림이며 자세한 처리 순서는 아래와 같다.

1. Master 노드에 쓰기 트랜잭션이 수행된다.
2. Master 노드는 데이터를 저장하고 트랜잭션에 대한 로그를 파일에 기록한다.(BIN LOG)
3. Slave 노드의 IO Thread는 Master 노드의 로그 파일(BIN LOG)를 파일(Replay Log)에 복사한다.
4. Slave 노드의 SQL Thread는 파일(Replay Log)를 한 줄씩 읽으며 데이터를 저장한다.

- 장점
    - DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
    - 비동기 방식으로 운영되어 지연 시간이 거의 없다.
- 단점
    - 노드들 간의 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
    - Master 노드가 다운되면 복구 및 대처가 까다롭다.
### 클러스터링
여러 개의 DB를 수평적인 구조로 구축하는 방식, 동기방식으로 노드들 간의 데이터 동기화

![](https://blog.kakaocdn.net/dn/oaVae/btqKOCg14ow/kkpZDYChulrTJvyqRVKLbk/img.png)

1. 1개의 노드에 쓰기 트랜잭션이 수행되고, COMMIT을 실행한다.
2. 실제 디스크에 내용을 쓰기 전에 다른 노드로 데이터의 복제를 요청한다.
3. 다른 노드에서 복제 요청을 수락했다는 신호(OK)를 보내고, 디스크에 쓰기를 시작한다.
4. 다른 노드로부터 신호(OK)를 받으면 실제 디스크에 데이터를 저장한다.

- 장점
    - 노드들 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
    - 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 계속 장애없이 운영할 수 있다.
- 단점
    - 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 Replication에 비해 쓰기 성능이 떨어진다.
    - 장애가 전파된 경우 처리가 까다로우며, 데이터 동기화에 의해 스케일링에 한계가 있다.


### 커네셕풀
